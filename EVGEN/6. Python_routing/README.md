# Программа на python, которая будет решать задачу маршрутизации

## Обзор проекта

Проект реализует систему моделирования компьютерной сети с динамической маршрутизацией. Система включает несколько маршрутизаторов, соединенных между собой, с автоматическим заполнением таблиц маршрутизации с использованием алгоритма Link-State.

## Структура файлов

```bash
RoutingProgram/
├── packet.py          # Классы Packet и PacketType
├── router.py          # Класс Router
├── network.py         # Класс Network и вспомогательные функции
└── main.py            # Главный скрипт с демонстрацией
```

## Как запустить:

1. Скачайте папку `RoutingProgram`

2. Запустите в ней файл `main.py`

```bash
python main.py
```

### Класс `PacketType` (Enum)

**Назначение**: Определяет типы пакетов, передаваемых в сети.

**Значения**:

- `DATA` - пакет с пользовательскими данными;

- `LS_ANNOUNCEMENT` - пакет объявления состояния канала (Link-State Advertisement);

### Класс `Packet`

**Назначение**: Представляет сетевой пакет с метаданными и полезной нагрузкой.

**Атрибуты**:

| Атрибут       | Тип          | Значение по умолчанию | Описание                                 |
| ------------- | ------------ | --------------------- | ---------------------------------------- |
| `source`      | `str`        | -                     | Имя маршрутизатора-отправителя           |
| `destination` | `str`        | -                     | Имя маршрутизатора-получателя            |
| `payload`     | `Any`        | -                     | Полезная нагрузка пакета                 |
| `type`        | `PacketType` | `PacketType.DATA`     | Тип пакета                               |
| `ttl`         | `int`        | `64`                  | Время жизни пакета (Time To Live)        |
| `path`        | `List[str]`  | `[]`                  | История пути пакета через маршрутизаторы |

**Методы**:

- `__str__()` - возвращает строковое представление пакета

**Пример использования**:

```python
packet = Packet(
    source="R1",
    destination="R4",
    payload="Hello World",
    type=PacketType.DATA,
    ttl=64
)
```

### Класс `Router`

**Назначение**: Моделирует сетевой маршрутизатор с интерфейсами, таблицей маршрутизации и алгоритмом Link-State.

**Атрибуты**:

| Атрибут         | Тип                | Описание                             |
| --------------- | ------------------ | ------------------------------------ |
| `name`          | `str`              | Уникальное имя маршрутизатора        |
| `interfaces`    | `Dict[str, Dict]`  | Словарь интерфейсов {имя: параметры} |
| `connections`   | `Dict[str, Tuple]` | Словарь соединений с соседями        |
| `routing_table` | `Dict[str, Dict]`  | Таблица маршрутизации                |
| `link_state_db` | `Dict[str, Dict]`  | База данных состояния каналов        |
| `seq_num`       | `int`              | Порядковый номер для LSA             |

**Основные методы**:

#### `add_interface(interface: str, ip: str, mask: str, metric: int)`

Добавляет интерфейс маршрутизатору.

**Параметры**:

- `interface` - имя интерфейса (например, "eth0");

- `ip` - IP-адрес интерфейса;

- `mask` - маска подсети (по умолчанию "255.255.255.0");

- `metric` - метрика интерфейса (по умолчанию 1);

#### `connect(other: Router, interface1: str, interface2: str, metric1: int, metric2: int)`

Устанавливает соединение с другим маршрутизатором.

**Параметры**:

- `other` - маршрутизатор для соединения;

- `interface1` - интерфейс текущего маршрутизатора;

- `interface2` - интерфейс целевого маршрутизатора;

- `metric1`, `metric2` - метрики соединения;

#### `update_link_state()`

Генерирует и рассылает LSA пакеты соседям с информацией о состоянии каналов.

#### `receive_lsa(lsa_data: Dict, source: str)`

Обрабатывает полученный LSA пакет и обновляет базу данных состояния каналов.

#### `calculate_routing_table()`

**Алгоритм**: Реализует алгоритм Дейкстры для вычисления кратчайших путей.

**Шаги работы**:

1. Инициализация расстояний до всех узлов как бесконечность;

2. Установка расстояния до себя как 0;

3. Использование приоритетной очереди для обработки узлов;

4. Обновление расстояний до соседей;

5. Построение таблицы маршрутизации на основе найденных путей;

#### `find_route(destination: str) → Optional[Dict]`

Находит маршрут до указанного узла.

**Возвращает**: Словарь с информацией о маршруте или `None` если маршрут не найден.

#### `send_packet(destination: str, payload: Any) → bool`

Отправляет пакет целевому узлу.

#### `forward_packet(packet: Packet, incoming_interface: str) → bool`

Пересылает пакет следующему узлу на основе таблицы маршрутизации.

#### `get_routing_table_str() → str`

Возвращает форматированное строковое представление таблицы маршрутизации.

### Класс `Network`

**Назначение**: Управляет совокупностью маршрутизаторов и обеспечивает сетевые операции.

**Атрибуты**:

| Атрибут   | Тип                 | Описание                              |
| --------- | ------------------- | ------------------------------------- |
| `routers` | `Dict[str, Router]` | Словарь маршрутизаторов {имя: объект} |

**Основные методы**:

#### `add_router(name: str) → Router`

Добавляет новый маршрутизатор в сеть.

#### `get_router(name: str) → Router`

Возвращает маршрутизатор по имени.

#### `update_all_link_states()`

Инициирует обновление состояния каналов на всех маршрутизаторах.

#### `simulate_link_failure(router1: str, router2: str)`

Имитирует обрыв связи между двумя маршрутизаторами.

#### `simulate_link_recovery(router1: str, router2: str, interface1: str, interface2: str, metric1: int, metric2: int)`

Имитирует восстановление связи между маршрутизаторами.

### Функция `create_test_network() → Network`

Создает тестовую сеть с 6 маршрутизаторами в топологии "кольцо + дополнительные связи".

**Топология сети**:

```bash
    R1 --- R2 --- R3
    |       |       |
    R6 --- R5 --- R4
    |               |
    -------- R1-R4 (доп. связь)
```

## main.py

**Назначение**: Демонстрационный скрипт с примерами использования системы.

**Основные функции**:

### `demonstrate_network_operations()`

Проводит полную демонстрацию работы сети:

1. Создание и инициализация сети;

2. Отправка пакетов по короткому маршруту;

3. Имитация обрыва связи;

4. Демонстрация перемаршрутизации;

5. Восстановление связи;

### `interactive_mode()`

Предоставляет интерактивный интерфейс для тестирования сети.

**Возможности интерактивного режима**:

- Просмотр таблиц маршрутизации;

- Отправка произвольных пакетов;

- Имитация сбоев и восстановлений связей;

## Принципы работы

### Алгоритм Link-State

1. **Обнаружение соседей**: Маршрутизаторы узнают о directly connected соседях;

2. **Рассылка LSA**: Каждый маршрутизатор рассылает информацию о своих связях;

3. **Построение графа**: Каждый узел строит полный граф сети;

4. **Вычисление путей**: Алгоритм Дейкстры находит кратчайшие пути;

5. **Заполнение таблиц**: Таблицы маршрутизации заполняются на основе вычислений;

### Обработка пакетов

1. **Проверка TTL**: Уменьшение времени жизни пакета;

2. **Определение назначения**: Проверка, достиг ли пакет цели;

3. **Поиск маршрута**: Поиск следующего хопа в таблице маршрутизации;

4. **Пересылка**: Передача пакета следующему маршрутизатору;

## Примеры использования

### Создание и настройка сети

```python
from network import create_test_network

network = create_test_network()
network.update_all_link_states()
```

### Отправка пакета

```python
router_r1 = network.get_router("R1")
router_r1.send_packet("R4", "Тестовое сообщение")
```

### Имитация сбоя

```python
network.simulate_link_failure("R3", "R4")
```

Эта система обеспечивает реалистичное моделирование сетевой маршрутизации с поддержкой динамической адаптации к изменениям топологии сети.


